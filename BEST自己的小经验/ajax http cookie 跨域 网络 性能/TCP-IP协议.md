> 目录
>
> 1.TCP连接三次握手
>
> 2.TCP连接关闭四次挥手
>
> 3.URL的组成
>
> 4.UDP
>
> 5.IP-DNS查询
>
> 6.全流程

**TCP是传输控制协议**

#### 1.TCP连接三次握手
![image](http://img.blog.csdn.net/20160309093354101?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

SYN攻击：

在三次握手过程中半连接状态的时候（服务端发送SYN-ACK之后，收到客户端的ACK之前的TCP连接就是半连接状态），SYN攻击就是客户端在短时间内伪造大量不存在的IP地址，并向服务端不断地发送SYN包，服务端回复确认包，并等待客户端的确认，由于源地址是不存在的，因此，服务端需要不断重发直至超时，这些伪造的SYN包占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。解决方式就是`检测SYN攻击`，当服务端上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：

    #netstat -nap | grep SYN_RECV

保活计时器：

- 设想有这样的情况：客户端已主动与服务器建立了TCP连接，但后来客户端的主机突然出现故障就会用到服务端的保活计时器。通常设为2小时，若2小时没有收到客户端的数据，服务器就发送一个探测报文段，以后则每隔75分钟发送一次。若一连发送10个探测报文段后仍无客户端的响应，服务器就认为客户端出现了故障，接着就关闭这个连接。
   
#### 2.TCP连接关闭四次挥手
![image](http://blog.chinaunix.net/attachment/201304/9/22312037_1365503104wDR0.png)

- 第一次挥手：客户端发送FIN=J，表示不再发送数据给服务端了。
- 第二次挥手：服务端接收到了FIN，发送一个ACK=J+1的包给客户端，告诉客户端收到了客户端不发送数据过来的要求。但是这时候服务端依旧可以发送数据给客户端，客户端依旧可以接收数据。
- 第三次挥手：服务端发送一个FIN，告诉客户端要彻底关闭连接了。
- 第四次挥手：客户端收到FIN，回复服务端一个ACK，然后等待2MSL（一般是1-4分钟），没有收到服务端的任何消息，就知道服务端收到了自己的ACK，双方就关闭了连接。如果等待期间，服务端没有收到ACK，会超时重发一个FIN给客户端，所以客户端需要等待一会儿，不能直接关闭连接。

#### 3.URL的组成

    ┌─────────────────────────────────────────────────────────────────────────────┐
    │                                    href                                     │
    ├──────────┬┬───────────┬─────────────────┬───────────────────────────┬───────┤
    │ protocol ││   auth    │      host       │           path            │ hash  │
    │          ││           ├──────────┬──────┼──────────┬────────────────┤       │
    │          ││           │ hostname │ port │ pathname │     search     │       │
    │          ││           │          │      │          ├─┬──────────────┤       │
    │          ││           │          │      │          │ │    query     │       │
    "  http:   // user:pass @ host.com : 8080   /p/a/t/h  ?  query=string   #hash "
    │          ││           │          │      │          │ │              │       │
    └──────────┴┴───────────┴──────────┴──────┴──────────┴─┴──────────────┴───────┘

`http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name`

1、协议部分

2、域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用

3、端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口80

4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”

5、文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名

6、锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分

7、参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

#### 4.UDP
链路层定义了主机的身份，即**MAC地址**， 而网络层定义了**IP地址**，明确了主机所在的网段，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。而每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包。

**UDP协议**的出现就是为了给每个应用程序标识身份，因为**UDP协议**定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息。这样，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。

但**UDP协议**没有确认机制，数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，就有了**TCP协议**，简单来说TCP就是有确认机制的**UDP协议**。

#### 5.IP-DNS查询
见笔记-`从输入一个URL到页面加载完成（上）`

#### 6.全流程

- 链路层：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；
- 网络层：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；
- 传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；
- 应用层：定义数据格式，并按照对应的格式解读数据。

    当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义；紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；然后网络协议加上了双方的IP地址，确认了双方的网络位置；最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。